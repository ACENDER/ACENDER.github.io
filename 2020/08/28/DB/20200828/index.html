<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SQL与数据库优化 | Acender</title><meta name="description" content="SQL与数据库优化文章内容:   为什么要进行数据库的优化    mysql优化方案流程    SQL及索引优化 : 准备数据, 如何发现有问题的SQL    mysql慢查询日志分析工具:   mysqldumpslow pt-query-digest    explain关键词分析SQL的执行计划    索引优化 :     数据库表结构的优化    数据库相关的配置优化    SQL的执行顺"><meta name="keywords" content="MySQL,数据库,优化"><meta name="author" content="Acender"><meta name="copyright" content="Acender"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://github.com/2020/08/28/DB/20200828/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//ta.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="SQL与数据库优化"><meta property="og:url" content="https://github.com/2020/08/28/DB/20200828/"><meta property="og:site_name" content="Acender"><meta property="og:description" content="SQL与数据库优化文章内容:   为什么要进行数据库的优化    mysql优化方案流程    SQL及索引优化 : 准备数据, 如何发现有问题的SQL    mysql慢查询日志分析工具:   mysqldumpslow pt-query-digest    explain关键词分析SQL的执行计划    索引优化 :     数据库表结构的优化    数据库相关的配置优化    SQL的执行顺"><meta property="og:image" content="https://github.com/img/default_cover.png"><meta property="article:published_time" content="2020-08-28T12:17:03.000Z"><meta property="article:modified_time" content="2020-12-10T07:28:11.823Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '1'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?69bc6dcd5c1d4ed9f296ca024a2db5af";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=1778191552"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '1778191552');
</script><script src="https://tajs.qq.com/stats?sId=66510289" charset="UTF-8" data-pjax="data-pjax"></script><link rel="stylesheet" href="/STZhongsong,YouYuan"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#121212","bgDark":"#121212","position":"bottom-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-12-10 07:28:11'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/footer.css"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="Acender" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">104</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书架</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">SQL与数据库优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">1. 为什么要进行数据库优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">2. mysql数据库优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SQL%E5%8F%8A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">3. SQL及索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 准备数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 查看表结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84SQL"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 如何发现有问题的SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MySQL%E6%85%A2%E6%9F%A5%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">5.</span> <span class="toc-text">4.MySQL慢查日志分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-mysqldumpslow"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 mysqldumpslow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-pt-query-digest"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 pt-query-digest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%80%9A%E8%BF%87explain%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">6.</span> <span class="toc-text">5. 通过explain查询分析SQL的执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%85%B7%E4%BD%93%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 具体慢查询优化的案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">6. 索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 如何创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%88%97%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 如何选择合适的列建立索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96SQL%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 索引优化SQL的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">7. 数据库表结构优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 数据库设计规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 数据库设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 数据库结构的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.1.</span> <span class="toc-text">7.3.1 选择合适的数据类型 :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8C%96%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.2.</span> <span class="toc-text">7.3.2 数据库表的范式化优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">8.3.3.</span> <span class="toc-text">7.3.3 数据库表的垂直拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-number">8.3.4.</span> <span class="toc-text">7.3.4 数据库表的水平拆分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">8. 数据库系统配置优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 优化配置参数-操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-MySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 优化配置参数- MySQL配置文件优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MySQL%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">9. MySQL的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-MySQL%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">11.</span> <span class="toc-text">10. MySQL执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">11.1.</span> <span class="toc-text">10.1 MyISAM存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">11.2.</span> <span class="toc-text">10.2 InnoDB存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-MEMORY%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">11.3.</span> <span class="toc-text">10.3 MEMORY存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-MERGE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">11.4.</span> <span class="toc-text">10.4 MERGE存储引擎</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Acender</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书架</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">SQL与数据库优化</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-28T12:17:03.000Z" title="发表于 2020-08-28 12:17:03">2020-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-10T07:28:11.823Z" title="更新于 2020-12-10 07:28:11">2020-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="SQL与数据库优化"><a href="#SQL与数据库优化" class="headerlink" title="SQL与数据库优化"></a>SQL与数据库优化</h2><p>文章内容:</p>
<ul>
<li><ol>
<li>为什么要进行数据库的优化</li>
</ol>
</li>
<li><ol start="2">
<li>mysql优化方案流程</li>
</ol>
</li>
<li><ol start="3">
<li>SQL及索引优化 : 准备数据, 如何发现有问题的SQL</li>
</ol>
</li>
<li><ol start="4">
<li>mysql慢查询日志分析工具:</li>
</ol>
<ul>
<li>mysqldumpslow</li>
<li>pt-query-digest</li>
</ul>
</li>
<li><ol start="5">
<li>explain关键词分析SQL的执行计划</li>
</ol>
</li>
<li><ol start="6">
<li>索引优化 : </li>
</ol>
</li>
<li><ol start="7">
<li>数据库表结构的优化</li>
</ol>
</li>
<li><ol start="8">
<li>数据库相关的配置优化</li>
</ol>
</li>
<li><ol start="9">
<li>SQL的执行顺序</li>
</ol>
</li>
<li><ol start="10">
<li>mysql的执行引擎的介绍</li>
</ol>
</li>
</ul>
<h2 id="1-为什么要进行数据库优化"><a href="#1-为什么要进行数据库优化" class="headerlink" title="1. 为什么要进行数据库优化"></a>1. 为什么要进行数据库优化</h2><ul>
<li><ol>
<li>避免网站页面出现访问错误</li>
</ol>
<ul>
<li><p>由于数据库连接timeout产生页面5xx错误 , to many connection</p>
</li>
<li><p>由于慢查询造成页面无法加载 : 由于数据库无法及时的返回数据, 导致页面一直无法返回</p>
</li>
<li><p>由于阻塞造成数据无法提交 : </p>
</li>
</ul>
</li>
<li><ol start="2">
<li>增加数据库的稳定性 </li>
</ol>
<ul>
<li>很多数据库问题都是由于低效的查询引起的</li>
</ul>
</li>
<li><ol start="3">
<li>优化用户体验</li>
</ol>
<ul>
<li>流畅页面的访问速度</li>
<li>良好的网站功能体验</li>
</ul>
</li>
</ul>
<h2 id="2-mysql数据库优化"><a href="#2-mysql数据库优化" class="headerlink" title="2. mysql数据库优化"></a>2. mysql数据库优化</h2><p>​    可以从哪几个方面进行数据库的优化？如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554818142711.png" alt="1554818142711"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A、SQL及索引优化</span><br><span class="line">    根据需求写出良好的SQL，并创建有效的索引，实现某一种需求可以多种写法，这时候我们就要选择一种效率最高的写法。这个时候就要了解sql优化</span><br><span class="line">B、数据库表结构优化</span><br><span class="line">    根据数据库的范式，设计表结构，表结构设计的好直接关系到写SQL语句。</span><br><span class="line">C、系统配置优化</span><br><span class="line">    大多数运行在Linux机器上，如tcp连接数的限制、打开文件数的限制、安全性的限制，因此我们要对这些配置进行相应的优化。</span><br><span class="line">D、硬件配置优化</span><br><span class="line">    选择适合数据库服务的cpu，更快的IO，更高的内存；cpu并不是越多越好，某些数据库版本有最大的限制，ＩＯ操作并不是减少阻塞。</span><br><span class="line"></span><br><span class="line">注：通过上图可以看出，该金字塔中，优化的成本从下而上逐渐增高，而优化的效果会逐渐降低。</span><br></pre></td></tr></table></figure>

<h2 id="3-SQL及索引优化"><a href="#3-SQL及索引优化" class="headerlink" title="3. SQL及索引优化"></a>3. SQL及索引优化</h2><h3 id="3-1-准备数据"><a href="#3-1-准备数据" class="headerlink" title="3.1 准备数据"></a>3.1 准备数据</h3><blockquote>
<p>在mysql官网中, 给我们提供了一个实例数据库, 直接将这个实例数据库导入即可</p>
</blockquote>
<ul>
<li><ol>
<li>页面地址:  <strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">https://dev.mysql.com/doc/sakila/en/sakila-installation.html</a></strong></li>
</ol>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554819609510.png" alt="1554819609510"></p>
<ul>
<li><ol start="2">
<li>点击实例数据下载地址, 下载即可</li>
</ol>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554819707172.png" alt="1554819707172"></p>
<ul>
<li><ol start="3">
<li>关于sakila-db.zip压缩包所包含的文件如下解释</li>
</ol>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554820032968.png" alt="1554820032968"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sakila-schema.sql文件包含创建Sakila数据库结构所需的所有CREATE语句，包括表、视图、存储过程和触发器。</span><br><span class="line">sakila-data.sql文件包含填充sakila-schema创建的结构所需的INSERT语句。以及必须在初始数据加载之后创建的触发器的定义。</span><br><span class="line">sakila.mwb文件是一个MySQL工作台数据模型，您可以在MySQL Workbench中打开它来检查数据库结构。</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>将 sakila-db.zip 上传到linux, 并解压</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用rz命令上传即可: 如果使用rz显示没有此命令, 输入 yum -y install lrzsz 下载即可</span><br><span class="line"></span><br><span class="line">由于是一个zip文件, 需要下载 unzip  才能解压压缩包:  yum -y install unzip</span><br><span class="line"></span><br><span class="line">解压压缩包: unzip sakila-db.zip</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li>在数据库中创建对应表和库</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">连接数据库: shell&gt; mysql -u root -p123456</span><br><span class="line">导入数据:  mysql&gt; SOURCE &#x2F;root&#x2F;sakila-db&#x2F;sakila-schema.sql;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="6">
<li>导入数据</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SOURCE &#x2F;root&#x2F;sakila-db&#x2F;sakila-data.sql;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="7">
<li>验证是否成功</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> sakila;  <span class="comment"># 使用数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>; <span class="comment"># 查看所有表</span></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554820749499.png" alt="1554820749499"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> film;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554820793242.png" alt="1554820793242"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> film_text;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554820824093.png" alt="1554820824093"></p>
<h3 id="3-2-查看表结构"><a href="#3-2-查看表结构" class="headerlink" title="3.2 查看表结构"></a>3.2 查看表结构</h3><blockquote>
<p>可通过sqlyog查看基本结构关系</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1555076306688.png" alt="1555076306688"></p>
<h3 id="3-3-如何发现有问题的SQL"><a href="#3-3-如何发现有问题的SQL" class="headerlink" title="3.3 如何发现有问题的SQL"></a>3.3 如何发现有问题的SQL</h3><blockquote>
<p>mysql提供了慢查询日志查看功能, 可以帮助查询某一条SQL执行的一些状态</p>
</blockquote>
<ul>
<li><ol>
<li>查询mysql是否开启慢查询日志</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;slow_query_log&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554822803211.png" alt="1554822803211"></p>
<ul>
<li><ol start="2">
<li>开启mysql的慢查询日志: </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;slow_query_log&#39;  ;</span><br><span class="line">&#x2F;&#x2F;查看是否开启慢查询日志</span><br><span class="line"></span><br><span class="line">set global log_queries_not_using_indexes&#x3D;on; &#x2F;&#x2F; 将不使用索引的慢查询日志进行记录</span><br><span class="line">set global slow_query_log&#x3D;on;  &#x2F;&#x2F;开启慢查询日志</span><br><span class="line"></span><br><span class="line">show variables like &#39;slow_query_log_file&#39;;</span><br><span class="line">&#x2F;&#x2F;查看慢查询日志存储的位置</span><br><span class="line"></span><br><span class="line">set global long_query_time&#x3D;1;  </span><br><span class="line">&#x2F;&#x2F;大于1秒钟的数据记录到慢日志中，如果设置为默认0，则会有大量的信息存储在磁盘中，磁盘很容易满掉</span><br></pre></td></tr></table></figure>

<ul>
<li>3)检测是否已经开启:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Show databases;</span><br><span class="line">Use sakila;</span><br><span class="line">select * from store;  &#x2F;&#x2F; 执行查询</span><br><span class="line">select * from staff;  &#x2F;&#x2F; 执行查询</span><br><span class="line"></span><br><span class="line">监听日志文件，看是否写入 : 注意  后面的日志文件的路径需要通过查询slow_query_log_file参数</span><br><span class="line">tail -100f &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;node01-slow.log</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1555077958885.png" alt="1555077958885"></p>
<hr>
<p>mysql慢查询日志存储的格式说明:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1555077980306.png" alt="1555077980306"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">    1、# Time: 190412 22:05:02    &gt;&gt;&gt;      查询的执行时间</span><br><span class="line">    2、# User@Host: root[root] @ localhost []  Id:     2 &gt;&gt;&gt; 执行sql的主机信息</span><br><span class="line">    3、# Query_time: 0.001274  Lock_time: 0.000164 Rows_sent: 7  Rows_examined: 7   &gt;&gt;&gt;&gt; SQL的执行信息：</span><br><span class="line">            Query_time：SQL的查询时间</span><br><span class="line">            Lock_time：锁定时间</span><br><span class="line">            Rows_sent：所发送的行数</span><br><span class="line">            Rows_examined：所扫描的行数</span><br><span class="line">    4、SET timestamp&#x3D;1555077861; &gt;&gt;&gt;&gt; SQL执行时间</span><br><span class="line">    5、select * from shop;  &gt;&gt;&gt;&gt;&gt; SQL的执行内容</span><br></pre></td></tr></table></figure>

<hr>
<p>如何通过慢查日志发现有问题的SQL</p>
<ul>
<li><ol>
<li>查询次数多且每次查询占用时间长的sql</li>
</ol>
<ul>
<li>通常为pt-query-digest分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li>
</ul>
</li>
<li><ol start="2">
<li>IO大的sql</li>
</ol>
<ul>
<li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li>
</ul>
</li>
<li><ol start="3">
<li>未命中的索引的SQL</li>
</ol>
<ul>
<li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li>
</ul>
</li>
</ul>
<h2 id="4-MySQL慢查日志分析工具"><a href="#4-MySQL慢查日志分析工具" class="headerlink" title="4.MySQL慢查日志分析工具"></a>4.MySQL慢查日志分析工具</h2><h3 id="4-1-mysqldumpslow"><a href="#4-1-mysqldumpslow" class="headerlink" title="4.1 mysqldumpslow"></a>4.1 mysqldumpslow</h3><p>​    如何进行查看慢查询日志，如果开启了慢查询日志，就会生成很多的数据，然后我们就可以通过对日志的分析，生成分析报表，然后通过报表进行优化。</p>
<ul>
<li>如何使用此工具:<ul>
<li>可通过命令 : mysqldumpslow -h  查看使用教程</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554824444498.png" alt="1554824444498"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -v  : 查看verbose(详细配置)信息</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554824911507.png" alt="1554824911507"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-slow.log : 查看慢查询日志的前10个分析结果</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554824997974.png" alt="1554824997974"></p>
<blockquote>
<p>上图两条就是分析的结果，每条结果都显示是执行时间，锁定时间，发送的行数，扫描的行数</p>
<pre><code>这个工具是最常用的工具，通过安装mysql进行附带安装，但是该工具统计的结果比较少，对我们的优化锁表现的数据还是比较少</code></pre>
</blockquote>
<h3 id="4-2-pt-query-digest"><a href="#4-2-pt-query-digest" class="headerlink" title="4.2 pt-query-digest"></a>4.2 pt-query-digest</h3><p>​    作为一名优秀的mysql dba也需要有掌握几个好用的mysql管理工具，所以我也一直在整理和查找一些能够便于管理mysql的利器。以后的一段时间内，将会花一大部分的精力去搜索这些工具。</p>
<p>性 能的管理一直都是摆在第一位的，dba的很多工作管理层都看不到也没有办法衡量价值，但是如果一个系统慢的跟蜗牛一样，dba通过监控调优把系统从崩溃边 缘重新拉回到高铁时代。这种价值和触动应该是巨大的。（很多企业的领导认为系统跑不动了就需要换更快的CPU、更大的内存、更快的存储，而且这还不是少 数，所以DBA的价值也一直体现不出来，薪水自然也就不会很高）</p>
<p>mysql 的日志是跟踪mysql性能瓶颈的最快和最直接的方式了，系统性能出现瓶颈的时候，首先要打开慢查询日志，进行跟踪；mk-query-digest这个工具网上号称mysql dba必须掌握的十大工具之首。</p>
<p> <strong>pt-query-digest</strong> 是用于分析mysql慢查询的一个工具，与mysqldumpshow工具相比，py-query_digest 工具的分析结果更具体，更完善。</p>
<ul>
<li>1） 安装pt-query-digest 工具</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/percona-toolkit/2.2.16/RPM/percona-toolkit-2.2.16-1.noarch.rpm &amp;&amp; yum <span class="keyword">install</span> -y  percona-toolkit<span class="number">-2.2</span><span class="number">.16</span><span class="number">-1.</span>noarch.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>检测是否安装完毕</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令行中输入：pt-summary</span><br><span class="line"></span><br><span class="line">显示如下图所示：说明安装成功！输入【[root@node03 mysql]# pt-query-digest --help】</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554825413336.png" alt="1554825413336"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554825437708.png" alt="1554825437708"></p>
<ul>
<li><ol start="3">
<li>pt-query-digest基本使用</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 查看服务器信息</span><br><span class="line">    命令：pt-summary</span><br><span class="line">2) 查看磁盘开销使用信息</span><br><span class="line">    命令：pt-diskstats</span><br><span class="line">3) 查看mysql数据库信息</span><br><span class="line">    命令：pt-mysql-summary --user&#x3D;root --password&#x3D;123456</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554825730467.png" alt="1554825730467"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">4) 分析慢查询日志</span><br><span class="line">    命令：pt-query-digest &#x2F;data&#x2F;mysql&#x2F;data&#x2F;db-3-12-slow.log</span><br><span class="line">5) 查找mysql的从库和同步状态</span><br><span class="line">    命令：pt-slave-find --host&#x3D;localhost --user&#x3D;root --password&#x3D;123456</span><br><span class="line">6) 查看mysql的死锁信息</span><br><span class="line">    命令：pt-deadlock-logger --user&#x3D;root --password&#x3D;123456 localhost</span><br><span class="line">7) 从慢查询日志中分析索引使用情况</span><br><span class="line">    命令：pt-index-usage slow_20131009.log</span><br><span class="line">8) 查找数据库表中重复的索引</span><br><span class="line">    命令：pt-duplicate-key-checker --host&#x3D;localhost --user&#x3D;root --password&#x3D;123456</span><br><span class="line">9) 查看mysql表和文件的当前活动IO开销</span><br><span class="line">    命令：pt-ioprofile</span><br><span class="line">10) 查看不同mysql配置文件的差异</span><br><span class="line">    命令: pt-config-diff &#x2F;etc&#x2F;my.cnf &#x2F;etc&#x2F;my_master.cnf</span><br><span class="line">11) pt-find查找mysql表和执行命令，示例如下</span><br><span class="line">    查找数据库里大于2G的表： pt-find --user&#x3D;root --password&#x3D;123456 --tablesize +2G</span><br><span class="line">    查找10天前创建，MyISAM引擎的表：pt-find --user&#x3D;root --password&#x3D;123456 --ctime +10 --engine MyISAM</span><br><span class="line">    查看表和索引大小并排序: pt-find --user&#x3D;root --password&#x3D;123456 --printf &quot;%T\t%D.%N\n&quot; | sort -rn</span><br><span class="line">12) pt-kill 杀掉符合标准的mysql进程</span><br><span class="line">    显示查询时间大于60秒的查询 : pt-kill --user&#x3D;root --password&#x3D;123456 --busy-time 60 --print</span><br><span class="line">    kill掉大于60秒的查询 : pt-kill --user&#x3D;root --password&#x3D;123456 --busy-time 60 --kill</span><br><span class="line">13) 查看mysql授权</span><br><span class="line">    1、pt-show-grants --user&#x3D;root --password&#x3D;123456</span><br><span class="line">    2、pt-show-grants --user&#x3D;root --password&#x3D;123456 --separate –revoke</span><br><span class="line">14) 验证数据库复制的完整性</span><br><span class="line">    命令: pt-table-checksum --user&#x3D;root --password&#x3D;123456</span><br></pre></td></tr></table></figure>

<p>其他导出相关的命令</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554827624275.png" alt="1554827624275"></p>
<h2 id="5-通过explain查询分析SQL的执行计划"><a href="#5-通过explain查询分析SQL的执行计划" class="headerlink" title="5. 通过explain查询分析SQL的执行计划"></a>5. 通过explain查询分析SQL的执行计划</h2><p>explain : SQL的执行计划侧面反映出了SQL的执行效率，具体执行方式只需要在执行的SQL前面加上explain关键词即可；</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554829092867.png" alt="1554829092867"></p>
<ul>
<li>各个字段说明</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554829137011.png" alt="1554829137011"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554829157103.png" alt="1554829157103"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">1）、id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。</span><br><span class="line"> </span><br><span class="line">2）、select_type列常见的有：</span><br><span class="line"></span><br><span class="line">A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</span><br><span class="line"></span><br><span class="line">B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</span><br><span class="line"></span><br><span class="line">C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</span><br><span class="line"></span><br><span class="line">D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响</span><br><span class="line"></span><br><span class="line">E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</span><br><span class="line"></span><br><span class="line">F：subquery：除了from子句中包含的子查询外，其他地方出现的子查询都可能是subquery</span><br><span class="line"></span><br><span class="line">G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</span><br><span class="line"></span><br><span class="line">H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</span><br><span class="line"> </span><br><span class="line">3）、table</span><br><span class="line">显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的&lt;derived N&gt;就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&lt;union M,N&gt;，与&lt;derived N&gt;类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</span><br><span class="line"> </span><br><span class="line">4）、type</span><br><span class="line">依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</span><br><span class="line"></span><br><span class="line">A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</span><br><span class="line"></span><br><span class="line">B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</span><br><span class="line"></span><br><span class="line">C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</span><br><span class="line"></span><br><span class="line">D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</span><br><span class="line"></span><br><span class="line">E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</span><br><span class="line"></span><br><span class="line">F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。</span><br><span class="line"></span><br><span class="line">G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</span><br><span class="line"></span><br><span class="line">H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</span><br><span class="line"></span><br><span class="line">I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</span><br><span class="line"></span><br><span class="line">J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</span><br><span class="line"></span><br><span class="line">K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</span><br><span class="line"></span><br><span class="line">L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</span><br><span class="line"> </span><br><span class="line">5）、possible_keys : 在查询一条SQL的时候, 这个SQL有可能会使用到多个索引,但是SQL在执行的时候, 只会选择其中的一个索引来使用</span><br><span class="line"></span><br><span class="line">查询可能使用到的索引都会在这里列出来</span><br><span class="line"> </span><br><span class="line">6）、key : 两个以上的索引称为复合索引</span><br><span class="line">查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</span><br><span class="line"> </span><br><span class="line">7）、key_len</span><br><span class="line">用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。</span><br><span class="line"> </span><br><span class="line">8）、ref</span><br><span class="line">如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</span><br><span class="line"> </span><br><span class="line">9）、rows</span><br><span class="line">这里是执行计划中估算的扫描行数，不是精确值</span><br><span class="line"> </span><br><span class="line">10）、extra</span><br><span class="line">这个列可以显示的信息非常多，有几十种，常用的有</span><br><span class="line"></span><br><span class="line">A：distinct：在select部分使用了distinc关键字</span><br><span class="line"></span><br><span class="line">B：no tables used：不带from字句的查询或者From dual查询</span><br><span class="line"></span><br><span class="line">C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</span><br><span class="line"></span><br><span class="line">D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</span><br><span class="line"></span><br><span class="line">E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。</span><br><span class="line"></span><br><span class="line">F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</span><br><span class="line"></span><br><span class="line">G：using sort_union，using_union，using intersect，using sort_intersection：</span><br><span class="line">using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集</span><br><span class="line">using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集</span><br><span class="line">using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。</span><br><span class="line"></span><br><span class="line">H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</span><br><span class="line"></span><br><span class="line">I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition</span><br><span class="line"></span><br><span class="line">J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个</span><br><span class="line"></span><br><span class="line">K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</span><br><span class="line"> </span><br><span class="line">除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息</span><br><span class="line"> </span><br><span class="line">11）、filtered</span><br><span class="line">使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</span><br></pre></td></tr></table></figure>

<h3 id="5-1-具体慢查询优化的案例"><a href="#5-1-具体慢查询优化的案例" class="headerlink" title="5.1 具体慢查询优化的案例"></a>5.1 具体慢查询优化的案例</h3><ul>
<li><ol>
<li>函数Max()的优化</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如: 查询订单的最后支付时间</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(payment_date) <span class="keyword">from</span> payment;  优化前</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554907552109.png" alt="1554907552109"></p>
<blockquote>
<p> 查看执行计划 : explain select max(payment_date) from payment;</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554907611980.png" alt="1554907611980"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554907659460.png" alt="1554907659460"></p>
<blockquote>
<p>可以看到显示的执行计划，并不是很高效，可以拖慢服务器的效率，如何优化了？</p>
<p>创建索引 :  create index inx_paydate on payment(payment_date);</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554907812968.png" alt="1554907812968"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554907839462.png" alt="1554907839462"></p>
<p>索引是顺序操作的，不需要扫描表，执行效率就会比较恒定</p>
<ul>
<li><ol start="2">
<li>函数count(*) 的优化</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">需求：在一条SQL中同时查询2006年和2007年电影的数量</span><br><span class="line">    错误写法 : </span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> film <span class="keyword">where</span> release_year=<span class="string">&#x27;2006&#x27;</span> <span class="keyword">or</span> release_year=<span class="string">&#x27;2007&#x27;</span>;</span><br><span class="line">    这两种查询只能查询出2006年和2007年的总数量, 但是2006年和2007年分别是多少无法判断出来</span><br><span class="line">    </span><br><span class="line">    正确的编写方式:</span><br><span class="line">        <span class="keyword">SELECT</span> release_year, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> film <span class="keyword">GROUP</span> <span class="keyword">BY</span> release_year <span class="keyword">HAVING</span> release_year=<span class="string">&#x27;2006&#x27;</span> <span class="keyword">OR</span> release_year=<span class="string">&#x27;2007&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>区别：count（*）和count（id）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t(id int);</span><br><span class="line"></span><br><span class="line">insert into t values(1),(2),(null);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554909710677.png" alt="1554909710677"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count（*）：select count(*)from t;</span><br></pre></td></tr></table></figure>

<p>​    <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554909740228.png" alt="1554909740228">4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count（id）：select count(id)from t;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554909775884.png" alt="1554909775884"></p>
<blockquote>
<p>说明：</p>
<p>​    count（id）是不包含null的值</p>
<p>​    count（*）是包含null的值</p>
<p>​    在创建表的时候, 尽可能的使用not null 的约束, 保证每一个字段默认值不是null值, 这样在执行count操作的时候, 就可以直接统计某一个字段的内容, 而不是统计所有的字段个数</p>
</blockquote>
<ul>
<li><ol start="3">
<li>子查询的优化</li>
</ol>
</li>
</ul>
<blockquote>
<p>​    子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把子查询优化为join查询但在优化是需要注意关联键是否有一对多的关系，要注意重复数据。</p>
</blockquote>
<blockquote>
<p>​    在编写代码的时候, 如果使用子查询可能会比多表连接查询更加的简单, 所以在开发阶段, 可以使用子查询, 只要能够满足需要就可以,但是在正式上线的商业化使用的时候, 尽可能将子查询更改jon查询会更好的一点,join查询的效率要比子查询效率更高</p>
</blockquote>
<p>​    查看我们所创建的t表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t1(tid int);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554909968108.png" alt="1554909968108"></p>
<p>​    接下来我们创建一个t1表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;create table t1(tid int);</span><br><span class="line"></span><br><span class="line">insert into t1 values(1);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910034780.png" alt="1554910034780"></p>
<p>​    我们要进行一个子查询，需求：查询t表中id在t1表中tid的所有数据；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> t.id <span class="keyword">in</span> (<span class="keyword">select</span> t1.tid <span class="keyword">from</span> t1);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910078533.png" alt="1554910078533"></p>
<p>​    接下来我们用join的操作来进行操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">join</span> t1 <span class="keyword">on</span> t.id =t1.tid;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910152279.png" alt="1554910152279"></p>
<p>​    通过上面结果来看，查询的结果是一致的，我们就将子查询的方式优化为join操作。</p>
<p>​    接下来，我们在t1表中再插入一条数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t1 values (1);</span><br><span class="line">select * from t1;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910501017.png" alt="1554910501017"></p>
<p>​    在这种情况下，如果我们使用子查询方式进行查询，返回的结果就是如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910543046.png" alt="1554910543046"></p>
<p>​    如果使用join方式进行查找，如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554910578273.png" alt="1554910578273"></p>
<p>​    在这种情况下出现了一对多的关系，会出现数据的重复，我们为了方式数据重复，不得不使用distinct关键词进行去重操作</p>
<p>​    注意：这个一对多的关系是我们开发过程中遇到的一个坑，出现数据重复，需要大家注意一下。</p>
<blockquote>
<p>总结: 需要将子查询更为 join 查询, 效率比较高的</p>
</blockquote>
<ul>
<li><ol start="4">
<li>group by的优化</li>
</ol>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需求：每个演员所参演影片的数量-（影片表和演员表）</span><br><span class="line">    <span class="keyword">explain</span> <span class="keyword">select</span> actor.first_name,actor.last_name,<span class="keyword">count</span>(*) <span class="keyword">from</span> sakila.film_actor <span class="keyword">inner</span> <span class="keyword">join</span> sakila.actor <span class="keyword">using</span>(actor_id) <span class="keyword">group</span> <span class="keyword">by</span> film_actor.actor_id;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554911481980.png" alt="1554911481980"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优化后的SQL：</span><br><span class="line">explain select actor.first_name,actor.last_name,c.cnt from sakila.actor inner join ( select actor_id,count(*) as cnt from sakila.film_actor group by actor_id) as c using(actor_id);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554911753274.png" alt="1554911753274"></p>
<p>说明：从上面的执行计划来看，这种优化后的方式没有使用临时文件和文件排序的方式了，取而代之的是使用了索引。查询效率老高了。</p>
<p>这个时候我们表中的数据比较大，会大量的占用IO操作，优化了sql执行的效率，节省了服务器的资源，因此我们就需要优化。</p>
<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) mysql 中using关键词的作用：也就是说要使用using,那么表a和表b必须要有相同的列。</span><br><span class="line">    using(id)  类似于: on a.id &#x3D; b.id</span><br><span class="line">    1.1) 在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是using。</span><br><span class="line"></span><br><span class="line">    1.2) 如果两个表的关联字段名是一样的，就可以使用Using来建立关系，简洁明了。</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li>Limit查询的优化</li>
</ol>
</li>
</ul>
<blockquote>
<p>Limit常用于分页处理，时长会伴随order by从句使用，因此大多时候使用Filesorts这样会造成大量的IO问题。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求：查询影片id和描述信息，并根据主题进行排序，取出从序号50条开始的5条数据。</span><br><span class="line">    select film_id,description from sakila.film order by title limit 50,5;</span><br><span class="line"></span><br><span class="line">在查看一下它的执行计划：</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912075885.png" alt="1554912075885"></p>
<p>对于这种操作，我们该用什么样的优化方式了？</p>
<p>优化步骤1：</p>
<p>​    使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优化1: select film_id,description from sakila.film order by film_id limit 50,5;</span><br><span class="line"></span><br><span class="line">查看一下执行计划</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912231297.png" alt="1554912231297"></p>
<p>​    那如果我们获取从500行开始的5条记录，执行计划又是什么样的了？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select film_id,description from sakila.film order by film_id limit 500,5 \G</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912273615.png" alt="1554912273615"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912291712.png" alt="1554912291712"></p>
<p>随着我们翻页越往后，IO操作会越来越大的，如果一个表有几千万行数据，翻页越后面，会越来越慢，因此我们要进一步的来优化。</p>
<p>优化步骤2、记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</p>
<p>上次limit是50,5的操作，因此我们在这次优化过程需要使用上次的索引记录值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化2: <span class="keyword">select</span> film_id,description <span class="keyword">from</span> sakila.film  <span class="keyword">where</span> film_id &gt;<span class="number">55</span> <span class="keyword">and</span> film_id&lt;=<span class="number">60</span> <span class="keyword">order</span> <span class="keyword">by</span> film_id <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912435600.png" alt="1554912435600"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554912477288.png" alt="1554912477288"></p>
<p>结论：扫描行数不变，执行计划是很固定，效率也是很固定的</p>
<p>注意事项：</p>
<p>​    主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足5行的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</p>
<blockquote>
<p>总结:</p>
<p>​    尽可能避免 filesorts(文件排序) 和 row的扫描(越少越好)</p>
<p>​    因为这两种操作都会增加io操作</p>
</blockquote>
<h2 id="6-索引优化"><a href="#6-索引优化" class="headerlink" title="6. 索引优化"></a>6. 索引优化</h2><h3 id="6-1-什么是索引"><a href="#6-1-什么是索引" class="headerlink" title="6.1 什么是索引"></a>6.1 什么是索引</h3><p>​    索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<p>​    数据库使用索引以找到特定值，然后顺指针找到包含该值的行。在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。索引的建立是表中比较有指向性的字段，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</p>
<p>类似于之前学习过的倒排索引的技术</p>
<p>​    提前建立好索引, 当查询的时候, 先查询索引, 找到这个索引对应表中的位置, 然后直接从这个位置将数据提取即可</p>
<h3 id="6-2-如何创建索引"><a href="#6-2-如何创建索引" class="headerlink" title="6.2 如何创建索引"></a>6.2 如何创建索引</h3><p>在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p>
<p>​    1、ALTER TABLE : 用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list)  &#x2F;&#x2F; 普通索引</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE (column_list)   &#x2F;&#x2F; 添加唯一索引</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_list)  &#x2F;&#x2F; 添加主键索引</span><br></pre></td></tr></table></figure>

<p>​    说明：其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>​    2、CREATE INDEX: 可对表增加普通索引或UNIQUE索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br></pre></td></tr></table></figure>

<p>​    说明：table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。</p>
<p>​    3、索引类型</p>
<p>​    在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</p>
<p>​    PRIMARY KEY索引和UNIQUE索引非常类似。</p>
<p>​    事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p>
<p>​    下面的SQL语句对students表在sid上添加PRIMARY KEY索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD PRIMARY KEY (sid)</span><br></pre></td></tr></table></figure>

<p>​    4、删除索引</p>
<p>​        可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> talbe_name ;  // 删除普通索引 和 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name ;  // 删除普通索引 和 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span> ; // 删除主键</span><br></pre></td></tr></table></figure>

<p>​    其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p>
<p>​    第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p>
<p>​    如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p>
<p>5、查看索引</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from tblname; </span><br><span class="line">mysql&gt; show keys from tblname;</span><br></pre></td></tr></table></figure>

<p>6、什么情况下，使用索引了？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、表的主关键字 : 主键</span><br><span class="line">2、自动建立唯一索引 : unique  和 外键</span><br><span class="line">3、表的字段唯一约束 : unique</span><br><span class="line">4、直接条件查询的字段（在SQL中用于条件约束的字段） : 在where后面频繁使用字段</span><br><span class="line">5、查询中与其它表关联的字段 : 外键</span><br><span class="line">6、查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度） : 排序的字段</span><br><span class="line">7、查询中统计或分组统计的字段 </span><br><span class="line">    如果这个字段只是进行分组, 并没有进行统计计算, 那么是不需要添加索引, 因为分组后的类型比较少</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">8、表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</span><br><span class="line">9、经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</span><br><span class="line">10、数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</span><br><span class="line">11、经常和主字段一块查询但主字段索引值比较多的表字段 : 如果要加, 也是添加复合索引, 将多个合并在一块</span><br><span class="line">12、对千万级MySQL数据库建立索引的事项及提高性能的手段</span><br><span class="line">    如果数据库中数据是在是太多了, 那么添加索引的操作, 本质上不会将效率提高太多</span><br><span class="line">    </span><br><span class="line">    一个表: 存储 1千万  磁盘空间 1G    建立索引, 需要一个G索引空间</span><br><span class="line">    如果数据太多了, 单独通过SQL来解决,可能效率非常的有限, 此时需要对整个的表结构进行优化</span><br></pre></td></tr></table></figure>

<h3 id="6-3-如何选择合适的列建立索引"><a href="#6-3-如何选择合适的列建立索引" class="headerlink" title="6.3 如何选择合适的列建立索引"></a>6.3 如何选择合适的列建立索引</h3><ul>
<li><p>1、在where从句，group by从句，order by从句，on从句中的列添加索引</p>
</li>
<li><p>2、索引字段越小越好（因为数据库数据存储单位是以“页”为单位的，数据存储的越多，IO也会越大）</p>
</li>
<li><p>3、离散度大的列放到联合索引的前面</p>
<ul>
<li>离散度 : 指的就是这个字段上的数据 范围是比较大的</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> payment <span class="keyword">where</span> staff_id =<span class="number">2</span> <span class="keyword">and</span> customer_id =<span class="number">584</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意:</p>
<p>​    是index （staff_id，customer_id）好，还是index（customer_id，staff_id）好</p>
<p>那我们怎么进行验证离散度好了？</p>
<p>A、我们先查看一下表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc payment;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554915126796.png" alt="1554915126796"></p>
<p>B、分别查看这两个字段中不同的id的数量，数量越多，则表明离散程度越大：因此可以通过下图看出：customer_id 离散程度大。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554915162182.png" alt="1554915162182"></p>
<p>​    结论：由于customer_id 离散程度大，使用index（customer_id，staff_id）好</p>
<p>C、mysql联合索引</p>
<p>​    ①命名规则 ：表名_字段名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、需要加索引的字段，要在where条件中</span><br><span class="line">2、数据量少的字段不需要加索引</span><br><span class="line">3、如果where条件中是OR关系，加索引不起作用</span><br><span class="line">4、符合最左原则</span><br></pre></td></tr></table></figure>



<p>​    ②什么是联合索引(复合索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、两个或更多个列上的索引被称作联合索引，又被称为是复合索引。</span><br><span class="line"></span><br><span class="line">2、利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。</span><br><span class="line">    </span><br><span class="line">    为什么要把离散度大的字段放置在最前面, 这样保证在使用索引的时候, 匹配度会高</span><br><span class="line">    </span><br><span class="line">    所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="6-4-索引优化SQL的方法"><a href="#6-4-索引优化SQL的方法" class="headerlink" title="6.4 索引优化SQL的方法"></a>6.4 索引优化SQL的方法</h3><p>1、索引的维护及优化（重复及冗余索引）</p>
<p>​    增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，过多的索引不但会影响使用效率，同时会影响查询效率，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p>
<blockquote>
<p>​    SQL在执行的时候, 会自动的分析需要什么那几个索引, 但是在实际使用的时候, 只会选择其中的一个索引, 这样导致, 如果索引个数有很多 , 就会导致分析使用那个索引的时间会变得更长</p>
</blockquote>
<p>2、如何找到重复和冗余的索引</p>
<p>​    重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如下表中的 primary key和ID列上的索引就是重复索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>, <span class="comment"># 主键索引</span></span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">unique</span>(<span class="keyword">id</span>)    <span class="comment"># 建立唯一索引</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure>

<p>​    冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，下面这个例子中key（name，id）就是一个冗余索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">    id int not null primary key,</span><br><span class="line">    name varchar(10) not null,</span><br><span class="line">    title varchar(50) not null,</span><br><span class="line">    key(name,id)  # 联合 索引 </span><br><span class="line">)engine&#x3D;innodb;</span><br></pre></td></tr></table></figure>

<p>​    说明：对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</p>
<p>3、如何查找重复索引</p>
<p>​    工具：使用pt-duplicate-key-checker工具检查重复及冗余索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554916135218.png" alt="1554916135218"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1555086535121.png" alt="1555086535121"></p>
<p>4、索引维护的方法</p>
<p>​    由于业务变更，某些索引是后续不需要使用的，就要进行删除。</p>
<p>​    在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-index-usage -uroot -padmin &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql-host-slow.log</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554916291282.png" alt="1554916291282"></p>
<p>​    附：<a target="_blank" rel="noopener" href="https://www.percona.com/downloads/">https://www.percona.com/downloads/</a></p>
<p>5、注意事项</p>
<p>​    设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1，创建索引</span><br><span class="line"></span><br><span class="line">    对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。 </span><br><span class="line"></span><br><span class="line">    但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</span><br><span class="line">    </span><br><span class="line">    索引条件: 如果一张表的数据量很大而符合条件的结果又很少  需要使用索引提高查询的效率</span><br><span class="line"></span><br><span class="line">2，复合索引</span><br><span class="line"></span><br><span class="line">    比如有一条语句是这样的：select * from users where area&#x3D;’beijing’ and age&#x3D;22;</span><br><span class="line"></span><br><span class="line">    如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引,或者是一个复合索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。</span><br><span class="line"></span><br><span class="line">    因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</span><br><span class="line">    </span><br><span class="line">    复合索引创建的时候:</span><br><span class="line">        1) 先要满足离散度排序</span><br><span class="line">        2) 将常用作查询的字段放置在最前面</span><br><span class="line"></span><br><span class="line">3，索引不会包含有NULL值的列</span><br><span class="line"></span><br><span class="line">    只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</span><br><span class="line"></span><br><span class="line">4，使用短索引 : 长度要短一点</span><br><span class="line"></span><br><span class="line">对字符串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。 </span><br><span class="line"></span><br><span class="line">5，排序的索引问题</span><br><span class="line"></span><br><span class="line">mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</span><br><span class="line"></span><br><span class="line">    如果这个索引已经在where条件后面已经使用了, 那么如果在排序的时候, 还要使用这个字段, 那么索引不会在这里生效了, 如果想要生效, 需要使用复合索引, </span><br><span class="line">    建议: 如果表的默认排序方式是可以满足需求, 那么不要认为添加排序操作</span><br><span class="line"></span><br><span class="line">6，like语句操作</span><br><span class="line"></span><br><span class="line">一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。</span><br><span class="line">    like查询是一个非常消耗资源的查询方式, like方式的查询一般扫描的行数都是比较多</span><br><span class="line"></span><br><span class="line">7，不要在列上进行运算 : 如果需要进行计算, 可以在业务层中进行分别的计算</span><br><span class="line"></span><br><span class="line">select * from users where YEAR(adddate)</span><br><span class="line"></span><br><span class="line">8，不使用NOT IN操作</span><br><span class="line"></span><br><span class="line">NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-数据库表结构优化"><a href="#7-数据库表结构优化" class="headerlink" title="7. 数据库表结构优化"></a>7. 数据库表结构优化</h2><h3 id="7-1-数据库设计规范"><a href="#7-1-数据库设计规范" class="headerlink" title="7.1 数据库设计规范"></a>7.1 数据库设计规范</h3><ul>
<li><ol>
<li>数据库命名规范</li>
</ol>
<ul>
<li><p>1.1) 采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</p>
</li>
<li><p>1.2) 命名简洁明确(长度不能超过30个字符);</p>
<blockquote>
<p> 例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀; </p>
<p> ​    除非是备份数据库可以加0-9的自然数：user_db_20151210;</p>
</blockquote>
</li>
</ul>
</li>
<li><ol start="2">
<li>数据库表名命名规范</li>
</ol>
<ul>
<li>2.1) 采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_‘组成;</li>
<li>2.2) 命名简洁明确,多个单词用下划线’_’分隔;</li>
</ul>
<blockquote>
<p>例如：user_login, user_profile, user_detail, user_role, user_role_relation,user_role_right, user_role_right_relation</p>
<p>注：表前缀’user_’可以有效的把相同关系的表显示在一起;</p>
</blockquote>
</li>
<li><ol start="3">
<li>数据库表字段名命名规范</li>
</ol>
<ul>
<li>3.1) 采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_‘组成;</li>
<li>3.2) 命名简洁明确,多个单词用下划线’_’分隔;</li>
</ul>
<blockquote>
<p>例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;</p>
</blockquote>
<ul>
<li>3.3) 每个表中必须有自增主键,add_time(默认系统时间): 默认的排序的方式</li>
<li>3.4) 表与表之间的相关联字段名称要求尽可能的相同;<ul>
<li>在进行多表查询的时候, 会有关联条件: </li>
</ul>
</li>
</ul>
</li>
<li><ol start="4">
<li>数据库表字段类型规范</li>
</ol>
<ul>
<li>4.1) 用尽量少的存储空间来存数一个字段的数据 :  能小不大的原则</li>
</ul>
<blockquote>
<p>例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</p>
</blockquote>
<ul>
<li><p>4.2) IP地址最好使用int类型: </p>
</li>
<li><p>4.3) 固定长度的类型最好使用char,例如：邮编;</p>
</li>
<li><p>4.4) 能使用tinyint就不要使用smallint,int;</p>
</li>
<li><p>4.5) 最好给每个字段一个默认值,最好不能为null;</p>
</li>
</ul>
</li>
<li><ol start="5">
<li>数据库表索引规范</li>
</ol>
<ul>
<li><p>5.1) 命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;</p>
</li>
<li><p>5.2) 为每个表创建一个主键索引;</p>
</li>
<li><p>5.3) 为每个表创建合理的索引;</p>
</li>
<li><p>5.4) 建立复合索引请慎重;</p>
</li>
</ul>
</li>
<li><ol start="6">
<li>简单熟悉数据库范式</li>
</ol>
<ul>
<li>第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);</li>
</ul>
<blockquote>
<p> 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</p>
</blockquote>
<ul>
<li>第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;</li>
</ul>
<blockquote>
<p> 备注：必须先满足第一范式;</p>
</blockquote>
<ul>
<li>第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;</li>
</ul>
<blockquote>
<p>备注1：必须先满足第二范式;</p>
<p>备注2：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</p>
<p>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</p>
</blockquote>
</li>
</ul>
<h3 id="7-2-数据库设计原则"><a href="#7-2-数据库设计原则" class="headerlink" title="7.2 数据库设计原则"></a>7.2 数据库设计原则</h3><ul>
<li><ol>
<li>核心原则</li>
</ol>
<ul>
<li>1.1) 不在数据库做运算;</li>
<li>1.2) cpu计算务必移至业务层;</li>
<li>1.3) 控制列数量(字段少而精,字段数建议在20以内)</li>
<li>1.4) 平衡范式与冗余(效率优先；往往牺牲范式)<ul>
<li>业务查询数据的时候, 能够用单表解决, 就不要不用使用多表查询</li>
</ul>
</li>
<li>1.5) 拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch)</li>
</ul>
</li>
<li><ol start="2">
<li>字段类原则</li>
</ol>
<ul>
<li>2.1) 用好数值类型(用合适的字段类型节约空间)</li>
<li>2.2) 字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能)</li>
<li>2.3) 避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效)</li>
<li>2.4) 少用text类型(尽量使用varchar代替text字段);</li>
</ul>
</li>
<li><ol start="3">
<li>索引类原则</li>
</ol>
<ul>
<li>3.1) 合理使用索引(改善查询,减慢更新,索引一定不是越多越好)</li>
<li>3.2) 字符字段必须建前缀索引;<ul>
<li>建立前缀索引:  控制长度即可, 默认如果不写长度,采用字段的长度</li>
</ul>
</li>
<li>3.3) 不在索引列做运算</li>
<li>3.4) innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了)</li>
<li>3.5) 不用外键(由程序保证约束)<ul>
<li>不要使用外键约束, 通过程序保证</li>
</ul>
</li>
</ul>
</li>
<li><ol start="4">
<li>sql类原则</li>
</ol>
<ul>
<li><p>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库)</p>
</li>
<li><p>简单的事务</p>
</li>
<li><p>避免使用trig/func(触发器、函数不用客户端程序取而代之)</p>
</li>
<li><p>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性)</p>
</li>
<li><p>OR改写为IN(or的效率是n级别);</p>
</li>
<li><p>OR改写为UNION(mysql的索引合并很弱智);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select id from t where phone &#x3D; ’159′ or name &#x3D; ‘john’;</span><br><span class="line">&#x3D;&gt;</span><br><span class="line">select id from t where phone&#x3D;’159′</span><br><span class="line">union</span><br><span class="line">select id from t where name&#x3D;’jonh’</span><br><span class="line">        避免负向%;</span><br><span class="line">        慎用count(*);</span><br><span class="line">        limit高效分页(limit越大，效率越低);</span><br><span class="line">        使用union all替代union(union有去重开销);</span><br><span class="line">        少用连接join;</span><br><span class="line">        使用group by;</span><br><span class="line">        请使用同类型比较;</span><br><span class="line">        打散批量更新;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="7-3-数据库结构的优化"><a href="#7-3-数据库结构的优化" class="headerlink" title="7.3 数据库结构的优化"></a>7.3 数据库结构的优化</h3><h4 id="7-3-1-选择合适的数据类型"><a href="#7-3-1-选择合适的数据类型" class="headerlink" title="7.3.1 选择合适的数据类型 :"></a>7.3.1 选择合适的数据类型 :</h4><p>数据类型的选择，重点在于“合适”二字，如何确定选择的数据类型是否合适了？</p>
<ul>
<li><ol>
<li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li>
</ol>
</li>
<li><ol start="2">
<li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li>
</ol>
</li>
<li><ol start="3">
<li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li>
</ol>
</li>
<li>4、 尽量少用text类型，非用不可时最好考虑分表。</li>
</ul>
<hr>
<p>案例:</p>
<ul>
<li>案例1 : int类型存储时间-时间转换<ul>
<li>使用int来存储日期时间，利用FROM_UNIXTIME(),UNIX_TIMESTAMP()两个函数来进行转换。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建表: </span><br><span class="line">create table test(</span><br><span class="line">    id int auto_increment not null,</span><br><span class="line">    timestr int ,</span><br><span class="line">    primary key(id)</span><br><span class="line">);</span><br><span class="line">导入数据：</span><br><span class="line">    insert into test (timestr) values (unix_timestamp(&#39;2018-05-29 16:00:00&#39;));</span><br><span class="line">    </span><br><span class="line">unix_timestamp : 将时间转换为int类型</span><br><span class="line">    将一个时间更为时间的毫秒值</span><br></pre></td></tr></table></figure>

<p>​    查询数据：如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970054886.png" alt="1554970054886"></p>
<p>​    时间进行转换：select FROM_UNIXTIME(timestr) from test;</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970106604.png" alt="1554970106604"></p>
<p>结论：</p>
<p>​    1、unix_timestamp()函数是将日期格式的数据转换为int类型</p>
<p>​    2、FROM_UNIXTIME(timestr)函数是将int类型转换为时间格式</p>
<p>案例二：ip地址的存储</p>
<p>​    172.125.125.125    </p>
<p>​    在我们的外部应用中，都要记录ip地址，大部分场合都是varchar（15）进行存储，就需要15个字节进行存储，但是bigint只需要8个字节进行存储，当数据量很大的时候（千万级别的数据），相差7个字节，但是不能小看这7个字节，给大家算一下。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970261522.png" alt="1554970261522"></p>
<p>​    一个字段就多这么多，那如果我们这样的字段需要上万个字段了？是需要很多的存储空间的。</p>
<p>​    使用bigint（8）来存储ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建表：</span><br><span class="line">create table sessions(</span><br><span class="line">    id int auto_increment not null,</span><br><span class="line">    ipaddress bigint,</span><br><span class="line">    primary key (id)</span><br><span class="line">);</span><br><span class="line">导入数据：</span><br><span class="line">    insert into sessions (ipaddress)values (inet_aton(&#39;192.168.0.1&#39;));</span><br><span class="line">转换：</span><br><span class="line">    select inet_ntoa(ipaddress) from sessions;  </span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970422160.png" alt="1554970422160"></p>
<p>​    检索:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970453418.png" alt="1554970453418"></p>
<blockquote>
<p>特殊: 一个是ip地址  和 时间保存</p>
<p>​    一般都可以采用存储为int类型, </p>
<p>总结: 在存储数据的时候, 如果这个数据可以转换为基本数据类型, 那么就不要使用复杂的类型</p>
<p>​    这样可以提高效率, 但是提高sql的编写难度</p>
</blockquote>
<h4 id="7-3-2-数据库表的范式化优化"><a href="#7-3-2-数据库表的范式化优化" class="headerlink" title="7.3.2 数据库表的范式化优化"></a>7.3.2 数据库表的范式化优化</h4><ul>
<li><ol>
<li>表范式化</li>
</ol>
</li>
</ul>
<blockquote>
<pre><code> 范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</code></pre>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554970881627.png" alt="1554970881627"></p>
<p>存在以下传递函数依赖关系：</p>
<p>（商品名称）-&gt;（分类）-&gt;（分类描述）</p>
<p>也就是说存在非关键字段 “分类描述”对关键字段“商品名称”的传递函数依赖。</p>
<p>不符合第三范式要求的表存在以下问题：</p>
<p>1、 数据冗余：（分类，分类描述）对于每一个商品都会进行记录。</p>
<p>2、 数据的插入异常</p>
<p>3、 数据的更新异常</p>
<p>4、 数据的删除异常（删除所有数据，分类和分类描述都会删除，没有所有的记录）</p>
<p>如何转换成符合第三范式的表（拆分表）：</p>
<p>​    将原来的不符合第三范式的表拆分为3个表</p>
<p>​    商品表、分类表、分类和商品的关系表</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971056671.png" alt="1554971056671"></p>
<blockquote>
<p>执行查询的时候, 会变得复杂: </p>
<p>​    请查询酒水饮料下有多少个商品, 以及酒水饮料描述也要一并展示</p>
</blockquote>
<ul>
<li><ol start="2">
<li>反范式化</li>
</ol>
</li>
</ul>
<blockquote>
<p>​    反范式化是指为了查询效率的考虑把原本符合第三范式的表“适当”的增加冗余，以达到优化查询效率的目的，反范式化是一种以<strong>空间来换取时间</strong>的操作。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971297241.png" alt="1554971297241"></p>
<p>如何查询订单信息？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.用户名，b.电话，b.地址，a.订单<span class="keyword">ID</span>，<span class="keyword">sum</span>（c.商品价格*c.商品数量）<span class="keyword">as</span> 订单价格</span><br><span class="line">    <span class="keyword">from</span> 订单表 <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">join</span> 用户表 <span class="keyword">as</span> b <span class="keyword">on</span> a.用户<span class="keyword">ID</span>=b.订单<span class="keyword">ID</span></span><br><span class="line">    <span class="keyword">join</span> 订单商品表 <span class="keyword">as</span> c <span class="keyword">on</span> c.订单<span class="keyword">ID</span>=b.订单<span class="keyword">ID</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> b.用户名，b.电话，b.地址，a.订单<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>

<p>​    对于这样的表结构，对于sum（），group by会产生临时表，增加IO量。我们怎么优化都效率不高，那我们怎么样才能让它效率高了，就需要一些字段进行冗余。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971375969.png" alt="1554971375969"></p>
<p>​    单表中增加了冗余字段，那SQL该怎么写了？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select a.用户名，a.电话，a.地址，a.订单ID,a.订单价格 </span><br><span class="line">from 订单表 as a</span><br></pre></td></tr></table></figure>

<p>​    说明：表结构的设计直接涉及到SQL的查询效率及优化。</p>
<h4 id="7-3-3-数据库表的垂直拆分"><a href="#7-3-3-数据库表的垂直拆分" class="headerlink" title="7.3.3 数据库表的垂直拆分"></a>7.3.3 数据库表的垂直拆分</h4><ul>
<li><ol>
<li>垂直拆分定义 : 所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</li>
</ol>
</li>
<li><ol start="2">
<li>垂直拆分原则</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通常垂直拆分可以按以下原则进行：  根据具体的业务操作</span><br><span class="line">    1、把不常用的字段单独存放到一个表中。</span><br><span class="line">    2、把大字段独立存放到一个表中。: 比如 text字段</span><br><span class="line">    3、把经常一起使用的字段放到一起。</span><br><span class="line">例子：以film表为例</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971870808.png" alt="1554971870808"></p>
<p>在该表中，title和description这两个字段占空间比较大，况且在使用频率也比较低，因此可以将其提取出来，将上面的一个表垂直拆分为两个表（film和film_ext）：如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971943866.png" alt="1554971943866"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554971960587.png" alt="1554971960587"></p>
<h4 id="7-3-4-数据库表的水平拆分"><a href="#7-3-4-数据库表的水平拆分" class="headerlink" title="7.3.4 数据库表的水平拆分"></a>7.3.4 数据库表的水平拆分</h4><ul>
<li><ol>
<li>为什么水平拆分</li>
</ol>
<ul>
<li>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的，</li>
</ul>
<p>以下面的peyment表为例来说明</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc payment;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554972580901.png" alt="1554972580901"></p>
<ul>
<li><ol start="2">
<li>水平不拆分原因</li>
</ol>
<ul>
<li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li>
</ul>
</li>
<li><ol start="3">
<li>如何将数据平均分为N份</li>
</ol>
<ul>
<li>拆表的过程是比较耗时的工程, 一般要选择服务器不忙的时候, 进行处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通常水平拆分的方法为：  hash取模计算</span><br><span class="line">1. 对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</span><br><span class="line">2. 针对不同的hashid把数据存储到不同的表中</span><br></pre></td></tr></table></figure>
</li>
<li><ol start="4">
<li>水平拆分面临的挑战</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、跨分区表进行数据查询</span><br><span class="line">    前端业务统计：查询 124574进行取模运算: 计算出这个id应该在那个表中存储的</span><br><span class="line">        业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</span><br><span class="line">2、统计及后台报表操作</span><br><span class="line">    但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-数据库系统配置优化"><a href="#8-数据库系统配置优化" class="headerlink" title="8. 数据库系统配置优化"></a>8. 数据库系统配置优化</h2><h3 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义"></a>8.1 定义</h3><p>​    数据库是基于操作系统的，目前大多数MySQL都是安装在linux系统之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能，下面就列出一些常用的系统配置。优化包括操作系统的优化及MySQL的优化</p>
<h3 id="8-2-优化配置参数-操作系统"><a href="#8-2-优化配置参数-操作系统" class="headerlink" title="8.2 优化配置参数-操作系统"></a>8.2 优化配置参数-操作系统</h3><ul>
<li><ol>
<li>操作系统的配置: </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">网络方面的配置，要修改&#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">1、增加tcp支持的队列数</span><br><span class="line">    net.ipv4.tcp_max_syn_backlog &#x3D; 65535</span><br><span class="line">2、减少断开连接时，资源回收(tcp有连接状态)</span><br><span class="line">    net.ipv4.tcp_max_tw_buckets &#x3D; 8000</span><br><span class="line">    net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class="line">    net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class="line">    net.ipv4.tcp_fin_timeout &#x3D; 10</span><br><span class="line"></span><br><span class="line">说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>打开文件数的限制 : </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件，增加以下内容以修改打开文件数量的限制（永久生效）</span><br><span class="line">    </span><br><span class="line">    *Soft nofile 65535</span><br><span class="line">    *Hard nofile 65535</span><br><span class="line">    </span><br><span class="line">如果一次有效，就要使用ulimit –n 65535即可。（默认情况是1024）</span><br><span class="line">除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件。</span><br></pre></td></tr></table></figure>

<h3 id="8-3-优化配置参数-MySQL配置文件优化"><a href="#8-3-优化配置参数-MySQL配置文件优化" class="headerlink" title="8.3 优化配置参数- MySQL配置文件优化"></a>8.3 优化配置参数- MySQL配置文件优化</h3><ul>
<li><ol>
<li>MySQL配置文件修改</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于&#x2F;etc&#x2F;my.cnf 或者是 &#x2F;etc&#x2F;mysql&#x2F;my.cnf在Windows系统配置文件可以是位于C:&#x2F;&#x2F;windows&#x2F;&#x2F;my.ini文件，MySQL查找配置文件的顺序可以通过以下方法获得。</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;mysqld --verbose --help | grep -A 1 &#39;default options&#39;</span><br></pre></td></tr></table></figure>

<p>执行后的结果如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554973872020.png" alt="1554973872020"></p>
<p>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。    </p>
<ul>
<li><ol start="2">
<li>MySQL配置文件-常用参数说明</li>
</ol>
<ul>
<li>2.1) 连接请求的变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">max_connections : </span><br><span class="line">    MySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。</span><br><span class="line">数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</span><br><span class="line">    show variables like &#39;max_connections&#39;; 最大连接数</span><br><span class="line">    show status like &#39;max_used_connections&#39;;响应的连接数</span><br><span class="line">    </span><br><span class="line">如下：</span><br><span class="line">    show variables like &#39;max_connections&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554974321531.png" alt="1554974321531"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;max_used_connections&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554974351077.png" alt="1554974351077"></p>
<p>说明：理想值设置为多大才合适了？</p>
<p>max_used_connections / max_connections * 100% （理想值≈ 85%）</p>
<p>​    如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">back_log :</span><br><span class="line">    MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</span><br><span class="line">    </span><br><span class="line">    back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP&#x2F;IP连接的侦听队列的大小。</span><br><span class="line">    </span><br><span class="line">    当观察你主机进程列表（mysql&gt; show full processlist），发现大量264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。</span><br><span class="line">    </span><br><span class="line">默认数值是50，可调优为128，对于Linux系统设置范围为小于512的整数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interactive_timeout :</span><br><span class="line">    一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。</span><br><span class="line">    默认数值是28800，可调优为7200。</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>缓冲区变量</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.1) key_buffer_size</span><br><span class="line">    </span><br><span class="line">    key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads &#x2F; key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。</span><br><span class="line">    </span><br><span class="line">    key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</span><br><span class="line"></span><br><span class="line">举例如下：</span><br><span class="line">    show variables like &#39;key_buffer_size&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554974839229.png" alt="1554974839229"></p>
<p>​    key_buffer_size为512MB，我们再看一下key_buffer_size的使用情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#39;key_read%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554974883513.png" alt="1554974883513"></p>
<p>​    一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：</p>
<p>​    key_cache_miss_rate ＝Key_reads / Key_read_requests * 100%，设置在1/1000左右较好</p>
<p>​    默认配置数值是8388608(8M)，主机有4GB内存，可以调优值268435456(256MB)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.2) query_cache_size</span><br><span class="line">    使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。</span><br><span class="line">    </span><br><span class="line">    与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。</span><br><span class="line">    </span><br><span class="line">query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</span><br><span class="line">    query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。</span><br><span class="line">    query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。</span><br><span class="line">    </span><br><span class="line">举例如下：</span><br><span class="line">    show global status like &#39;qcache%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554975215349.png" alt="1554975215349"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">查询缓存碎片率&#x3D; Qcache_free_blocks &#x2F; Qcache_total_blocks * 100%</span><br><span class="line">    如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。</span><br><span class="line">    </span><br><span class="line">查询缓存利用率&#x3D; (query_cache_size – Qcache_free_memory) &#x2F; query_cache_size * 100%</span><br><span class="line">    查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。</span><br><span class="line">    </span><br><span class="line">查询缓存命中率&#x3D; (Qcache_hits – Qcache_inserts) &#x2F; Qcache_hits * 100%</span><br><span class="line">    示例服务器查询缓存碎片率＝20.46％，查询缓存利用率＝62.26％，查询缓存命中率＝1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">2.3) record_buffer_size</span><br><span class="line">    每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</span><br><span class="line"></span><br><span class="line">    默认数值是131072(128K)，可改为16773120 (16M)</span><br><span class="line">    </span><br><span class="line">2.4) read_rnd_buffer_size</span><br><span class="line">    随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</span><br><span class="line"></span><br><span class="line">2.5) sort_buffer_size</span><br><span class="line">    每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</span><br><span class="line">默认数值是2097144(2M)，可改为16777208 (16M)。</span><br><span class="line"></span><br><span class="line">2.6) join_buffer_size :联合查询操作所能使用的缓冲区大小。</span><br><span class="line">    record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</span><br><span class="line"></span><br><span class="line">2.7) table_cache</span><br><span class="line">    表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</span><br><span class="line">    1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</span><br><span class="line"></span><br><span class="line">2.8) max_heap_table_size</span><br><span class="line">    用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size&#x3D;#</span><br><span class="line">    这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</span><br><span class="line">    </span><br><span class="line">2.9) tmp_table_size</span><br><span class="line">    通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</span><br><span class="line">    show global status like &#39;created_tmp%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554975753577.png" alt="1554975753577"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：</span><br><span class="line">    Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &lt;&#x3D; 25% 比如上面的服务器    Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% ＝1.20%，应该相当好了</span><br><span class="line">    默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I&#x2F;O堵塞</span><br><span class="line">    </span><br><span class="line">2.10) thread_cache_size</span><br><span class="line">    可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</span><br><span class="line">    通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</span><br><span class="line">    </span><br><span class="line">2.11) thread_concurrency</span><br><span class="line">    推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为8</span><br><span class="line"></span><br><span class="line">2.12) wait_timeout</span><br><span class="line">    指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>配置InnoDB的几个变量</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">3.1) innodb_buffer_pool_size</span><br><span class="line">    对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</span><br><span class="line">    根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</span><br><span class="line">    show status like &#39;innodb%&#39;;</span><br><span class="line"></span><br><span class="line">3.2) innodb_flush_log_at_trx_commit</span><br><span class="line">    主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</span><br><span class="line">    实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</span><br><span class="line">    根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</span><br><span class="line"></span><br><span class="line">3.3) innodb_log_buffer_size</span><br><span class="line">    log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</span><br><span class="line"></span><br><span class="line">3.4) innodb_additional_mem_pool_size</span><br><span class="line">    该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</span><br><span class="line">    根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</span><br><span class="line">    innodb_thread_concurrency&#x3D;8</span><br><span class="line">    推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</span><br><span class="line">    </span><br><span class="line">3.5) skip-name-resolve</span><br><span class="line">    # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，</span><br><span class="line">    # 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</span><br><span class="line">#skip-networking</span><br><span class="line">    </span><br><span class="line">back_log &#x3D; 600</span><br><span class="line">    # MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，</span><br><span class="line">    # 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。</span><br><span class="line">    # 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到</span><br><span class="line">max_connections时，新来的请求将会被存在堆栈中，</span><br><span class="line">    # 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</span><br><span class="line">    # 另外，这值（back_log）限于您的操作系统对到来的TCP&#x2F;IP连接的侦听队列的大小。</span><br><span class="line">    # 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。</span><br><span class="line"></span><br><span class="line">max_connections &#x3D; 1000</span><br><span class="line">    # MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</span><br><span class="line"></span><br><span class="line">max_connect_errors &#x3D; 6000</span><br><span class="line">    # 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。</span><br><span class="line"></span><br><span class="line">open_files_limit &#x3D; 65535</span><br><span class="line">    # MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，</span><br><span class="line">    # 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。</span><br><span class="line"></span><br><span class="line">table_open_cache &#x3D; 128</span><br><span class="line">    # MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64</span><br><span class="line">    # 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；</span><br><span class="line">    # 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上</span><br><span class="line"></span><br><span class="line">max_allowed_packet &#x3D; 4M</span><br><span class="line">    # 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。</span><br><span class="line">    # 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。</span><br><span class="line"></span><br><span class="line">binlog_cache_size &#x3D; 1M</span><br><span class="line">    # 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K</span><br><span class="line"></span><br><span class="line">max_heap_table_size &#x3D; 8M</span><br><span class="line">    # 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变</span><br><span class="line"></span><br><span class="line">tmp_table_size &#x3D; 16M</span><br><span class="line">    # MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。</span><br><span class="line">    # 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。</span><br><span class="line">    # 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果</span><br><span class="line"></span><br><span class="line">read_buffer_size &#x3D; 2M</span><br><span class="line">    # MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。</span><br><span class="line">    # 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能</span><br><span class="line"></span><br><span class="line">read_rnd_buffer_size &#x3D; 8M</span><br><span class="line">    # MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，</span><br><span class="line">    # MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</span><br><span class="line"></span><br><span class="line">sort_buffer_size &#x3D; 8M</span><br><span class="line">    # MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。</span><br><span class="line">    # 如果不能，可以尝试增加sort_buffer_size变量的大小</span><br><span class="line"></span><br><span class="line">join_buffer_size &#x3D; 8M</span><br><span class="line">    # 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享</span><br><span class="line"></span><br><span class="line">thread_cache_size &#x3D; 8</span><br><span class="line">    # 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，</span><br><span class="line">    # 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，</span><br><span class="line">    # 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)</span><br><span class="line">    # 根据物理内存设置规则如下：</span><br><span class="line">    # 1G —&gt; 8</span><br><span class="line">    # 2G —&gt; 16</span><br><span class="line">    # 3G —&gt; 32</span><br><span class="line">    # 大于3G —&gt; 64</span><br><span class="line"></span><br><span class="line">query_cache_size &#x3D; 8M</span><br><span class="line">    #MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，</span><br><span class="line">    # 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。</span><br><span class="line">    # 通过检查状态值’Qcache_%’，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，</span><br><span class="line">    # 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，</span><br><span class="line">    # 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲</span><br><span class="line"></span><br><span class="line">query_cache_limit &#x3D; 2M</span><br><span class="line">    #指定单个查询能够使用的缓冲区大小，默认1M</span><br><span class="line"></span><br><span class="line">key_buffer_size &#x3D; 4M</span><br><span class="line">    #指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，</span><br><span class="line">    # 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，</span><br><span class="line">    # 可以知道key_buffer_size设置是否合理。比例key_reads&#x2F;key_read_requests应该尽可能的低，</span><br><span class="line">    # 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得)。注意：该参数值设置的过大反而会是服务器整体效率降低</span><br><span class="line"></span><br><span class="line">ft_min_word_len &#x3D; 4</span><br><span class="line">    # 分词词汇最小长度，默认4</span><br><span class="line"></span><br><span class="line">transaction_isolation &#x3D; REPEATABLE-READ</span><br><span class="line">    # MySQL支持4种事务隔离级别，他们分别是：</span><br><span class="line">    # READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</span><br><span class="line">    # 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED</span><br><span class="line"></span><br><span class="line">log_bin &#x3D; mysql-bin</span><br><span class="line">binlog_format &#x3D; mixed</span><br><span class="line">expire_logs_days &#x3D; 30 #超过30天的binlog删除</span><br><span class="line">log_error &#x3D; &#x2F;data&#x2F;mysql&#x2F;mysql-error.log #错误日志路径</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line">long_query_time &#x3D; 1 #慢查询时间 超过1秒则为慢查询</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;data&#x2F;mysql&#x2F;mysql-slow.log</span><br><span class="line">performance_schema &#x3D; 0</span><br><span class="line">explicit_defaults_for_timestamp</span><br><span class="line">#lower_case_table_names &#x3D; 1 #不区分大小写</span><br><span class="line">skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启</span><br><span class="line">default-storage-engine &#x3D; InnoDB #默认存储引擎</span><br><span class="line"></span><br><span class="line">innodb_file_per_table &#x3D; 1</span><br><span class="line">    # InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间</span><br><span class="line">    # 独立表空间优点：</span><br><span class="line">    # 1．每个表都有自已独立的表空间。</span><br><span class="line">    # 2．每个表的数据和索引都会存在自已的表空间中。</span><br><span class="line">    # 3．可以实现单表在不同的数据库中移动。</span><br><span class="line">    # 4．空间可以回收（除drop table操作处，表空不能自已回收）</span><br><span class="line">    # 缺点：</span><br><span class="line">        # 单表增加过大，如超过100G</span><br><span class="line">    # 结论：</span><br><span class="line">        # 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files</span><br><span class="line"></span><br><span class="line">innodb_open_files &#x3D; 500</span><br><span class="line">    # 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size &#x3D; 64M</span><br><span class="line">    # InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.</span><br><span class="line">    # 这里你设置越大,你在存取表里面数据时所需要的磁盘I&#x2F;O越少.</span><br><span class="line">    # 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</span><br><span class="line">    # 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</span><br><span class="line">    # 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</span><br><span class="line">    # 所以不要设置的太高.</span><br><span class="line"></span><br><span class="line">innodb_write_io_threads &#x3D; 4</span><br><span class="line">innodb_read_io_threads &#x3D; 4</span><br><span class="line"></span><br><span class="line">    # innodb使用后台线程处理数据页上的读写 I&#x2F;O(输入输出)请求,根据你的 CPU 核数来更改,默认是4</span><br><span class="line">    # 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64</span><br><span class="line"></span><br><span class="line">innodb_thread_concurrency &#x3D; 0</span><br><span class="line">    # 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量</span><br><span class="line"></span><br><span class="line">innodb_purge_threads &#x3D; 1</span><br><span class="line">    # InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。</span><br><span class="line">    # 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单</span><br><span class="line">    # 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1</span><br><span class="line"></span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 2</span><br><span class="line">    # 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。</span><br><span class="line">    # 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1</span><br><span class="line">    # 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。</span><br><span class="line">    # 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。</span><br><span class="line">    # 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘</span><br><span class="line">    # 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。</span><br><span class="line">    # 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</span><br><span class="line"># 总结</span><br><span class="line"># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</span><br><span class="line"></span><br><span class="line">innodb_log_buffer_size &#x3D; 2M</span><br><span class="line">    # 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间</span><br><span class="line"></span><br><span class="line">innodb_log_file_size &#x3D; 32M</span><br><span class="line">    # 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间</span><br><span class="line"></span><br><span class="line">innodb_log_files_in_group &#x3D; 3</span><br><span class="line">    # 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</span><br><span class="line"></span><br><span class="line">innodb_max_dirty_pages_pct &#x3D; 90</span><br><span class="line">    # innodb主线程刷新缓存池中的数据，使脏数据比例小于90%</span><br><span class="line"></span><br><span class="line">innodb_lock_wait_timeout &#x3D; 120</span><br><span class="line">    # InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒</span><br><span class="line"></span><br><span class="line">bulk_insert_buffer_size &#x3D; 8M</span><br><span class="line">    # 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。</span><br><span class="line"></span><br><span class="line">myisam_sort_buffer_size &#x3D; 8M</span><br><span class="line">    # MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区</span><br><span class="line"></span><br><span class="line">myisam_max_sort_file_size &#x3D; 10G</span><br><span class="line">    # 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出</span><br><span class="line"></span><br><span class="line">myisam_repair_threads &#x3D; 1</span><br><span class="line">    # 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)</span><br><span class="line"></span><br><span class="line">interactive_timeout &#x3D; 28800</span><br><span class="line">    # 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）</span><br><span class="line"></span><br><span class="line">wait_timeout &#x3D; 28800</span><br><span class="line">    # 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，</span><br><span class="line">    # 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）</span><br><span class="line">    # MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，</span><br><span class="line">    # 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，</span><br><span class="line">    # 最终肯定会达到MySQL Server的连接上限数，这会报’too many connections’的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。</span><br><span class="line">    # 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，</span><br><span class="line">    # 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line">max_allowed_packet &#x3D; 16M #服务器发送和接受的最大包长度</span><br><span class="line">[myisamchk]</span><br><span class="line">key_buffer_size &#x3D; 8M</span><br><span class="line">sort_buffer_size &#x3D; 8M</span><br><span class="line">read_buffer &#x3D; 4M</span><br><span class="line">write_buffer &#x3D; 4M</span><br></pre></td></tr></table></figure>

<p>附录：</p>
<p>1、查看innodb的相关参数信息 : show variables like ‘innodb%’;</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554976444715.png" alt="1554976444715"></p>
<p>2、查看innodb的相关参数状态 : how status like ‘innodb%’;</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554976493881.png" alt="1554976493881"></p>
<h2 id="9-MySQL的执行顺序"><a href="#9-MySQL的执行顺序" class="headerlink" title="9. MySQL的执行顺序"></a>9. MySQL的执行顺序</h2><p>​    MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/lishisan/Images/raw/master/DB/optimize/1554976814314.png" alt="1554976814314"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select [distinct] 字段列表 from 表 inner join 表2 on 关联条件 where 条件 group by  分组的字段  having 聚合函数条件 order by 排序字段 [desc | asc] limit start,rows</span><br></pre></td></tr></table></figure>

<p>下面我们来具体分析一下查询处理的每一个阶段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</span><br><span class="line">2. ON: 对虚表VT1进行ON筛选，只有那些符合&lt;join-condition&gt;的行才会被记录在虚表VT2中。</span><br><span class="line">3. JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</span><br><span class="line">4. WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合&lt;where-condition&gt;的记录才会被插入到虚拟表VT4中。</span><br><span class="line">5. GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</span><br><span class="line">6. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</span><br><span class="line">7.HAVING： 对虚拟表VT6应用having过滤，只有符合&lt;having-condition&gt;的记录才会被 插入到虚拟表VT7中。</span><br><span class="line">8.order by : 对Vt7进行排序操作, 将符合排序条件数据插入到虚拟表 VT8</span><br><span class="line">9.limit :  从VT8表中获取对应的数据, 插入到VT9表中, 将最后这个虚拟表展示给用户即可</span><br><span class="line"></span><br><span class="line">总结: 每执行一个关键词, 就会产生一张虚拟表,而这个虚拟表就表示执行完这个关键词中内容后, 得到的结果数据, 如果后面没有关键词了, 那么直接将会这个虚拟表展示给用户即可</span><br></pre></td></tr></table></figure>

<h2 id="10-MySQL执行引擎"><a href="#10-MySQL执行引擎" class="headerlink" title="10. MySQL执行引擎"></a>10. MySQL执行引擎</h2><h3 id="10-1-MyISAM存储引擎"><a href="#10-1-MyISAM存储引擎" class="headerlink" title="10.1 MyISAM存储引擎"></a>10.1 MyISAM存储引擎</h3><p>​    不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</p>
<p>​    支持3种不同的存储格式，分别是：静态表；动态表；压缩表</p>
<p>静态表：</p>
<p>​    表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</p>
<p>动态表：</p>
<p>​    记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</p>
<p>压缩表：</p>
<p>​    因为每个记录是被单独压缩的，所以只有非常小的访问开支</p>
<h3 id="10-2-InnoDB存储引擎"><a href="#10-2-InnoDB存储引擎" class="headerlink" title="10.2 InnoDB存储引擎"></a>10.2 InnoDB存储引擎</h3><p>​    该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。 </p>
<p>InnoDB存储引擎的特点：支持自动增长列，支持外键约束</p>
<p>mysql默认的存储引擎: InnoDB</p>
<h3 id="10-3-MEMORY存储引擎"><a href="#10-3-MEMORY存储引擎" class="headerlink" title="10.3 MEMORY存储引擎"></a>10.3 MEMORY存储引擎</h3><p>​    MEMORY方案基于内存的存储数据: 将数据存储在内存中</p>
<p>​    </p>
<p>​    Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。<br>​    MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围</p>
<p>Hash索引优点： </p>
<p>​    Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 </p>
<p>Hash索引缺点： </p>
<p>​    那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</p>
<p>​    Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</p>
<h3 id="10-4-MERGE存储引擎"><a href="#10-4-MERGE存储引擎" class="headerlink" title="10.4 MERGE存储引擎"></a>10.4 MERGE存储引擎</h3><p>​    Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
<p>面试:</p>
<p>​    如何对数据库进行优化: 学历检测+笔试+面试</p>
<p>​        笔试: 比较轻松</p>
<p>​        1) SQL相关的优化: </p>
<p>​             建立合适的索引或者建立合适复合索引提高查询的效率</p>
<p>​             将子查询更改为 join查询</p>
<p>​             将not in  改为 not exit</p>
<p>​        2) 表的结构优化:  </p>
<p>​            1) 选择合适的表的数据结构: 能小不大原则</p>
<p>​            2) 使用拆分表的策略: 垂直拆分 和 水平拆分</p>
<p>​        3) 修改操作系统和 mysql相关的配置:</p>
<p>​        4) 提高服务器的硬件配置 : CPU  内存  磁盘</p>
<p>​        </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Acender</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/2020/08/28/DB/20200828/">https://github.com/2020/08/28/DB/20200828/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com" target="_blank">Acender</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/%E4%BC%98%E5%8C%96/">优化</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/01/Month/ONE_202009/"><img class="prev-cover" data-lazy-src="https://gitee.com/lishisan/one2020/raw/master/20200901-2928.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第九十六卷</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/19/Spark/spark1/"><img class="next-cover" data-lazy-src="/img/spark-logo.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Apache Spark 3.0：全新功能知多少</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Acender</div><div class="footer_custom_text">-The World is Yours-</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'hTTFRyiofXyJITsWFoz3cNhf-MdYXbMMI',
      appKey: 'I7DHK7OpdMWAhqcOsBBxdmEt',
      placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://github.com/2020/08/28/DB/20200828/'
    this.page.identifier = '2020/08/28/DB/20200828/'
    this.page.title = 'SQL与数据库优化'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://lishisan.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script></div></body></html>